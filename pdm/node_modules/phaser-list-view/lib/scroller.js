'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math_utils = require('./utils/math_utils');

var _math_utils2 = _interopRequireDefault(_math_utils);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ptHelper = new Phaser.Point();

var defaultOptions = {
  from: 0,
  to: 200,
  direction: 'y',
  momentum: false,
  snapping: false,
  bouncing: false,
  deceleration: 0.5, // value between 0 and 1
  overflow: 20,
  snapStep: 10,
  emitMoving: false,
  duration: 2, // (s) duration of the inertial scrolling simulation.
  speedLimit: 3, // set maximum speed. Higher values will allow faster scroll (which comes down to a bigger offset for the duration of the momentum scroll) note: touch motion determines actual speed, this is just a limit.
  flickTimeThreshold: 100, // (ms) determines if a flick occurred: time between last updated movement @ touchmove and time @ touchend, if smaller than this value, trigger inertial scrolling
  offsetThreshold: 30, // (pixels) determines if calculated offset is above this threshold
  acceleration: 0.5, // increase the multiplier by this value, each time the user swipes again when still scrolling. The multiplier is used to multiply the offset. Set to 0 to disable.
  accelerationT: 250, // (ms) time between successive swipes that determines if the multiplier is increased (if lower than this value)
  maxAcceleration: 4,
  time: {}, // contains timestamps of the most recent down, up, and move events
  multiplier: 1, //acceleration multiplier, don't edit here
  swipeEnabled: false,
  swipeThreshold: 5, // (pixels) must move this many pixels for a swipe action
  swipeTimeThreshold: 250, // (ms) determines if a swipe occurred: time between last updated movement @ touchmove and time @ touchend, if smaller than this value, trigger swipe
  minDuration: 0.5,
  addListeners: true
};

// Pure logic scroller
// Originally adapted from http://yusyuslabs.com/tutorial-momentum-scrolling-inside-scrollable-area-with-phaser-js/
//

var Scroller = function () {
  function Scroller(game, clickObject) {
    var maskLimits = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
    var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

    _classCallCheck(this, Scroller);

    this.game = game;
    this.clickObject = clickObject;

    this.maskLimits = maskLimits;

    this.o = this.options = Object.assign({}, defaultOptions, options);

    this._updateMinMax();

    this.dispatchValues = { step: 0, total: 0, percent: 0 };

    this.addListeners();

    this.clickables = [];

    this.isDown = false; // isDown is true when the down event has fired but the up event has not
    this.isScrolling = false; // isScrolling is true when the down event has fired but the complete event has not

    this.scrollObject = {};

    this.init();

    this.tweenScroll = this.game.add.tween(this.scrollObject).to({}, 0, Phaser.Easing.Quartic.Out);
    this.tweenScroll.onUpdateCallback(this.handleUpdate, this);
    this.tweenScroll.onComplete.add(this.handleComplete, this);
  }

  _createClass(Scroller, [{
    key: 'destroy',
    value: function destroy() {
      this.tweenScroll.stop();
      this.removeListeners();
      this.clickObject.destroy();
      this.clickables = null;
      this.options = this.o = null;
      this.maskLimits = null;
      this.enabled = false;
      this.game = null;
      this.dispatchValues = null;
      this.isDown = null;
      this.target = null;
      this.destroyed = true;
    }
  }, {
    key: 'addListeners',
    value: function addListeners() {
      this.events = {
        onUpdate: new Phaser.Signal(),
        onInputUp: new Phaser.Signal(),
        onInputDown: new Phaser.Signal(),
        onInputMove: new Phaser.Signal(),
        onComplete: new Phaser.Signal(),
        onSwipe: new Phaser.Signal()
      };

      if (this.o.addListeners) {
        this.clickObject.inputEnabled = true;
        this.clickObject.events.onInputDown.add(this.handleDown, this);
        this.clickObject.events.onInputUp.add(this.handleUp, this);
      }
    }
  }, {
    key: 'removeListeners',
    value: function removeListeners() {
      if (this.o.addListeners) {
        this.clickObject.events.onInputDown.remove(this.handleDown, this);
        this.clickObject.events.onInputUp.remove(this.handleUp, this);
      }

      for (var property in this.events) {
        if (this.events.hasOwnProperty(property)) {
          this.events[property].dispose();
        }
      }
    }
  }, {
    key: 'enable',
    value: function enable() {
      this.enabled = true;
    }
  }, {
    key: 'disable',
    value: function disable() {
      this.enabled = false;
    }
  }, {
    key: 'init',
    value: function init() {
      this.scrollObject[this.o.direction] = this.o.from;
      this.maxOffset = this.maskLimits[this.o.direction] * this.o.speedLimit;
      this.enable();
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.tweenScroll.pause();
      this.o.multiplier = 1;
      this.init();
    }
  }, {
    key: 'setFromTo',
    value: function setFromTo(_from, _to) {
      this.o.from = _from;
      this.o.to = _to;
      this._updateMinMax();
    }
  }, {
    key: 'isTweening',
    value: function isTweening() {
      return this.tweenScroll.isRunning;
    }
  }, {
    key: 'registerClickables',
    value: function registerClickables(clickables) {
      this.clickables = clickables;
    }
  }, {
    key: 'handleDown',
    value: function handleDown(target, pointer) {
      if (!this.enabled) return;
      this.isDown = true;
      // console.log('input down', pointer.y)
      this.target = this.requested = this.scrollObject[this.o.direction];
      this.o.time.down = pointer.timeDown;

      if (this.o.addListeners) this.game.input.addMoveCallback(this.handleMove, this);

      //check if block is currently scrolling and set multiplier
      if (this.isTweening() && this.o.time.down - this.o.time.up < this.o.accelerationT) {
        //swipe while animation was happening, increase multiplier
        this.o.multiplier += this.o.acceleration;
        // console.log('swipe while animation is happening', this.o.multiplier)
      } else {
        //reset
        this.o.multiplier = 1;
      }

      //stop tween for touch-to-stop
      this.tweenScroll.stop();
      this.tweenScroll.pendingDelete = false;

      (0, _util.dispatchClicks)(pointer, this.clickables, 'onInputDown');
      this.events.onInputDown.dispatch(target, pointer);
    }
  }, {
    key: 'handleMove',
    value: function handleMove(pointer, x, y) {
      if (!this.enabled) return;
      this.isScrolling = true;
      _ptHelper.set(x, y);
      this.diff = this.old - _ptHelper[this.o.direction];

      this.diff = this._requestDiff(this.diff, this.target, this.min, this.max, this.o.overflow);

      this.target -= this.diff;

      this.old = _ptHelper[this.o.direction];

      //store timestamp for event
      this.o.time.move = this.game.time.time;

      this.acc = Math.min(Math.abs(this.diff / 30), this.o.maxAcceleration);

      //go ahead and move the block
      this.scrollObject[this.o.direction] = this.target;
      this.handleUpdate();

      if (this.o.emitMoving) this.events.onInputMove.dispatch(pointer, x, y);
    }
  }, {
    key: 'handleUp',
    value: function handleUp(target, pointer) {
      this.isDown = false;
      // console.log('end')
      if (this.o.addListeners) this.game.input.deleteMoveCallback(this.handleMove, this);

      //store timestamp for event
      this.o.time.up = pointer.timeUp;

      if (this.o.time.up - this.o.time.down > this.o.accelerationT) {
        this.o.multiplier = 1; // reset
      }

      var o = {
        duration: 1,
        target: this.target
      };

      // *** BOUNCING
      if (!this.o.bouncing) o.duration = 0.01;

      if (!this.o.infinite && this.scrollObject[this.o.direction] > this.max) {
        this.target = this.max;
        this.tweenTo(o.duration, this.target);
      } else if (!this.o.infinite && this.scrollObject[this.o.direction] < this.min) {
        this.target = this.min;
        this.tweenTo(o.duration, this.target);
      } else {
        // *** MOMENTUM
        this._addMomentum(o);

        // *** SWIPING
        this._addSwiping(o, pointer);

        // *** SNAPPING
        this._addSnapping(o);

        // *** LIMITS
        this._addLimits(o);

        // *** DURATION
        this._calculateDuration(o);

        this.tweenTo(o.duration, o.target);
      }

      (0, _util.dispatchClicks)(pointer, this.clickables, 'onInputUp');
      this.events.onInputUp.dispatch(target, pointer, _util.dispatchClicks);
    }
  }, {
    key: '_addMomentum',
    value: function _addMomentum(o) {
      if (!this.o.momentum) return o.target;

      //distance to move after release
      var offset = Math.pow(this.acc, 2) * this.maskLimits[this.o.direction];
      offset = Math.min(this.maxOffset, offset);
      offset = this.diff > 0 ? -this.o.multiplier * offset : this.o.multiplier * offset;

      if (this.o.time.up - this.o.time.move < this.o.flickTimeThreshold && offset !== 0 && Math.abs(offset) > this.o.offsetThreshold) {
        o.target += offset;
      }
      return o;
    }
  }, {
    key: '_addSwiping',
    value: function _addSwiping(o, pointer) {
      var swipeDistance = Math.abs(this.down - this.current);
      if (this.o.swipeEnabled && this.o.time.up - this.o.time.down < this.o.swipeTimeThreshold && swipeDistance > this.o.swipeThreshold) {
        var direction = pointer[this.o.direction] < this.down ? 'forward' : 'backward';

        if (direction == 'forward') {
          o.target -= this.o.snapStep / 2;
        } else {
          o.target += this.o.snapStep / 2;
        }

        this.events.onSwipe.dispatch(direction);
      }
      return o;
    }
  }, {
    key: '_addSnapping',
    value: function _addSnapping(o) {
      if (!this.o.snapping) {
        return o;
      }
      o.target = _math_utils2.default.nearestMultiple(o.target, this.o.snapStep);
      return o;
    }
  }, {
    key: '_addLimits',
    value: function _addLimits(o) {
      if (this.o.infinite) return o;
      o.target = Math.max(o.target, this.min);
      o.target = Math.min(o.target, this.max);
      return o;
    }
  }, {
    key: '_calculateDuration',
    value: function _calculateDuration(o) {
      var distance = Math.abs(o.target - this.scrollObject[this.o.direction]);
      o.duration = this.o.duration * distance / this.maxOffset;
      o.duration = Math.max(this.o.minDuration, o.duration);
      return o;
    }
  }, {
    key: '_requestDiff',
    value: function _requestDiff(diff, target, min, max, overflow) {
      if (this.o.infinite) return diff;

      var scale = 0;
      if (target > max) {
        scale = (max + overflow - target) / overflow;
        diff *= scale;
      } else if (target < min) {
        scale = -(min - overflow - target) / overflow;
        diff *= scale;
      }
      return diff;
    }
  }, {
    key: 'tweenToSnap',
    value: function tweenToSnap(duration, snapIndex) {
      var target = this.o.from - this.o.snapStep * snapIndex;
      this.tweenTo(duration, target);
    }

    /**
     * [tweenTo tween to scroller to the target]
     * @param  {Number} duration duration in seconds
     * @param  {Number} target   target relative to the scroller space (usually pixels, but can be angle)
     */

  }, {
    key: 'tweenTo',
    value: function tweenTo(duration, target) {
      if (duration == 0) return this.setTo(target);

      //stop a tween if it is currently happening
      var o = _defineProperty({}, this.o.direction, target);

      this.tweenScroll.onUpdateCallback(this.handleUpdate, this);
      this.tweenScroll.onComplete.add(this.handleComplete, this);

      this.tweenScroll.updateTweenData('vEnd', o, -1);
      this.tweenScroll.updateTweenData('duration', duration * 1000, -1);
      this.tweenScroll.updateTweenData('percent ', 0, -1);

      this.tweenScroll.start();
    }

    // TODO - not really sure what this cancel method should do.
    // Obviously it's meant to cancel a currently active scroll...but I'm
    // not sure what expect from that.

  }, {
    key: 'cancel',
    value: function cancel() {
      this.isDown = false;
    }

    /**
     * [setTo sets the scroller to the target]
     * @param  {Number} target   target relative to the scroller space (usually pixels, but can be angle)
     */

  }, {
    key: 'setTo',
    value: function setTo(target) {
      //stop a tween if it is currently happening
      this.scrollObject[this.o.direction] = target;
      this.tweenScroll.stop();

      this.handleUpdate();
      this.handleComplete();
    }
  }, {
    key: 'handleUpdate',
    value: function handleUpdate() {
      if (!this.enabled) return;
      if (this.o.infinite) {
        this.dispatchValues.total = Phaser.Math.wrap(this.scrollObject[this.o.direction], this.min, this.max);
      } else {
        this.dispatchValues.total = this.scrollObject[this.o.direction];
      }

      var step = this.dispatchValues.total - this.previousTotal;
      if (step < -this.length / 2) {
        step = step + this.length;
      } else if (step > this.length / 2) {
        step = step - this.length;
      }

      this.dispatchValues.step = step;
      this.dispatchValues.percent = _math_utils2.default.percentageBetween2(this.dispatchValues.total, this.o.from, this.o.to);
      this.events.onUpdate.dispatch(this.dispatchValues);

      this.previousTotal = this.dispatchValues.total;
    }
  }, {
    key: 'handleComplete',
    value: function handleComplete() {
      if (!this.enabled) return;
      this.isScrolling = false;
      // reset multiplier when finished
      this.o.multiplier = 1;
      this.events.onComplete.dispatch();
    }
  }, {
    key: '_updateMinMax',
    value: function _updateMinMax() {
      this.min = Math.min(this.o.from, this.o.to);
      this.max = Math.max(this.o.from, this.o.to);
      this.length = Math.abs(this.max - this.min);
      this.previousTotal = this.o.from;
    }
  }]);

  return Scroller;
}();

exports.default = Scroller;