'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _util = require('./util');

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultOptions = {
  direction: 'auto',
  autoDetectThreshold: _config2.default.AUTO_DETECT_THRESHOLD
};

// Scroller Event Dispatcher is a centralized place to listener for events useful for scrollers
// The main feature of this class is the 'auto detect' for x and y directions.
// If you set 'direction' to 'auto', events won't dispatch until a direction is detected.
//

var ScrollerEventDispatcher = function () {
  function ScrollerEventDispatcher(game, clickObject) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, ScrollerEventDispatcher);

    this.game = game;
    this.clickObject = clickObject;
    this.clickables = [];

    this.o = this.options = Object.assign({}, defaultOptions, options);

    this.addListeners();
  }

  _createClass(ScrollerEventDispatcher, [{
    key: 'addListeners',
    value: function addListeners() {
      this.events = {
        onInputUp: new Phaser.Signal(),
        onInputDown: new Phaser.Signal(),
        onInputMove: new Phaser.Signal(),
        onDirectionSet: new Phaser.Signal()
      };

      this.clickObject.inputEnabled = true;
      this.enable();
      this.clickObject.events.onInputDown.add(this.handleDown, this);
      this.clickObject.events.onInputUp.add(this.handleUp, this);
    }
  }, {
    key: 'removeListeners',
    value: function removeListeners() {
      this.clickObject.events.onInputDown.remove(this.handleDown, this);
      this.clickObject.events.onInputUp.remove(this.handleUp, this);

      for (var property in this.events) {
        if (this.events.hasOwnProperty(property)) {
          this.events[property].removeAll();
        }
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.removeListeners();
    }
  }, {
    key: 'enable',
    value: function enable() {
      this.enabled = true;
    }
  }, {
    key: 'disable',
    value: function disable() {
      this.enabled = false;
    }
  }, {
    key: 'setDirection',
    value: function setDirection(direction) {
      this.direction = direction;
      this.events.onDirectionSet.dispatch(direction);
    }

    /**
     * [registerClickables]
     * If a standard click occurs on the dispatcher surface we want to handle the click.
     * @param  {Array[DisplayObjects]} clickables - Check these clickables AND their children for standard phaser input events.
     *                                              e.g. displayObject.events.onInputUp
     */

  }, {
    key: 'registerClickables',
    value: function registerClickables(clickables) {
      this.clickables = clickables;
    }
  }, {
    key: 'dispatchClicks',
    value: function dispatchClicks(pointer, clickables, type) {
      var found = (0, _util.dispatchClicks)(pointer, clickables, type);
      if (type == 'onInputDown') {
        this.currentDown = found;
      }
      return found;
    }
  }, {
    key: 'handleDown',
    value: function handleDown(target, pointer) {
      var _this = this;

      if (!this.enabled) {
        this.clickBlocked = true;
        return;
      }
      this.clickBlocked = false;

      if (this.o.direction == 'auto') {
        this.direction = null;
        this.old = null;
      } else {
        this.setDirection(this.o.direction);
        this.old = this.down = pointer[this.direction];
      }

      this.game.input.addMoveCallback(this.handleMove, this);

      this.dispatchClicks(pointer, this.clickables, 'onInputDown');
      this.events.onInputDown.dispatch(target, pointer, function (clickables, type) {
        return _this.dispatchClicks(pointer, clickables, 'onInputDown');
      });
    }
  }, {
    key: 'handleMove',
    value: function handleMove(pointer, x, y) {
      if (!this.enabled) return;

      if (!this.direction && this.o.direction == 'auto') {
        var xDist = Math.abs(pointer.positionDown.x - x);
        var yDist = Math.abs(pointer.positionDown.y - y);
        if (xDist > this.o.autoDetectThreshold || yDist > this.o.autoDetectThreshold) {
          this._cancelCurrentDown(pointer);
          var direction = xDist > yDist ? 'x' : 'y';
          this.setDirection(direction);
        } else {
          return;
        }
      }

      this.events.onInputMove.dispatch(pointer, x, y);
    }
  }, {
    key: 'handleUp',
    value: function handleUp(target, pointer) {
      var _this2 = this;

      if (!this.enabled || this.clickBlocked) return;
      this.game.input.deleteMoveCallback(this.handleMove, this);
      this.dispatchClicks(pointer, this.clickables, 'onInputUp');
      this.events.onInputUp.dispatch(target, pointer, function (clickables, type) {
        return _this2.dispatchClicks(pointer, clickables, 'onInputUp');
      });
      this.currentDown = null;
    }
  }, {
    key: '_cancelCurrentDown',
    value: function _cancelCurrentDown(pointer) {
      if (this.currentDown && this.currentDown.events && this.currentDown.events.onInputUp) {
        this.currentDown.events.onInputUp.dispatch(this.currentDown, pointer, false);
      }
      this.currentDown = null;
    }
  }]);

  return ScrollerEventDispatcher;
}();

exports.default = ScrollerEventDispatcher;