'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _math_utils = require('./utils/math_utils');

var _math_utils2 = _interopRequireDefault(_math_utils);

require('gsap');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ptHelper = new Phaser.Point();

// ** WORK IN PROGRESS **
//
// Similar to the Scroller class but there is no focus on a start and end of the scroll surface.
// For example with Scroller if you swiped left 3 times you would continue to go further left and
// closer to the end of the limit.
// With BasicSwiper if you swiped left 3 times, each time you receive values between -1 and 1, depending
// on the direction you swipe.
//
// TODO - consolidate BasicSwiper and Scroller. At least they could share same functions
//
var BasicSwiperCore = function BasicSwiperCore(game, bounds) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];


  this.game = game;

  var defaultOptions = {
    from: 0,
    to: 200,
    direction: 'y',
    snapStep: 10,
    duration: 1, // (s) duration of the inertial scrolling simulation.
    time: {}, // contains timestamps of the most recent down, up, and move events
    swipeThreshold: 5, // (pixels) must move this many pixels for a swipe action
    swipeTimeThreshold: 250 };

  // (ms) determines if a swipe occurred: time between last updated movement @ touchmove and time @ touchend, if smaller than this value, trigger swipe
  this.o = this.options = _lodash2.default.extend(defaultOptions, options);

  this._updateMinMax();

  this.addListeners();

  this.scrollObject = {};
  this.scrollObject[this.o.direction] = this.o.from;

  // set tween that will be re-used for moving scrolling sprite
  this.tweenScroll = TweenMax.to(this.scrollObject, 0, {
    ease: Quart.easeOut,
    onUpdate: this.handleUpdate,
    onUpdateScope: this,
    onComplete: this.handleComplete,
    onCompleteScope: this
  });
};

BasicSwiperCore.prototype = Object.create({
  addListeners: function addListeners() {
    this.events = {
      onUpdate: new Phaser.Signal(),
      onInputUp: new Phaser.Signal(),
      onInputDown: new Phaser.Signal(),
      onInputMove: new Phaser.Signal(),
      onComplete: new Phaser.Signal(),
      onSwipe: new Phaser.Signal()
    };
  },
  removeListeners: function removeListeners() {
    _lodash2.default.forIn(this.events, function (signal, key) {
      signal.removeAll();
    });
  },
  destroy: function destroy() {
    this.removeListeners();
  },
  isTweening: function isTweening() {
    return TweenMax.isTweening(this.scrollObject);
  },
  handleDown: function handleDown(target, pointer) {
    this.old = this.down = pointer[this.o.direction];
    this.target = 0;
    console.log('set down', this.target);
    this.o.time.down = pointer.timeDown;

    //stop tween for touch-to-stop
    this.tweenScroll.pause();

    this.events.onInputDown.dispatch(target, pointer);
  },
  handleMove: function handleMove(pointer, x, y) {
    _ptHelper.set(x, y);
    if (this.old == null) this.old = _ptHelper[this.o.direction];
    this.diff = this.old - _ptHelper[this.o.direction];
    this.target -= this.diff;

    this.old = _ptHelper[this.o.direction];

    this.scrollObject[this.o.direction] = this.target;
    console.log('diff', this.diff, this.target);
    this.handleUpdate();
  },
  handleUp: function handleUp(target, pointer) {
    //store timestamp for event
    this.o.time.up = pointer.timeUp;

    var o = {
      duration: this.o.duration,
      target: this.target
    };

    // *** SWIPING
    this._addSwiping(o, pointer);

    // *** SNAPPING
    this._addSnapping(o);

    this.tweenTo(o.duration, o.target);

    this.events.onInputUp.dispatch(target, pointer);
  },
  _addSwiping: function _addSwiping(o, pointer) {
    var swipeDistance = Math.abs(this.down - this.old);
    if (this.o.time.up - this.o.time.down < this.o.swipeTimeThreshold && swipeDistance > this.o.swipeThreshold) {
      var direction = pointer[this.o.direction] < this.down ? 'forward' : 'backward';

      if (direction == 'forward') {
        o.target -= this.o.snapStep / 2;
      } else {
        o.target += this.o.snapStep / 2;
      }

      this.events.onSwipe.dispatch(direction);
    }
    return o;
  },
  _addSnapping: function _addSnapping(o) {
    o.target = _math_utils2.default.nearestMultiple(o.target, this.o.snapStep);
    return o;
  },
  tweenTo: function tweenTo(duration, target) {
    // console.log('tweenTo', duration, target)
    //stop a tween if it is currently happening
    var o = {};
    o[this.o.direction] = target;

    this.tweenScroll.pause();
    this.tweenScroll.duration(duration);
    this.tweenScroll.updateTo(o, true);
    this.tweenScroll.restart();
  },


  // dispatches a value between -1 and 1 depending on the direction of the swipe action.
  handleUpdate: function handleUpdate() {
    this.events.onUpdate.dispatch(_math_utils2.default.scaleBetween(-1, 1, _math_utils2.default.percentageBetween2(this.scrollObject[this.o.direction], -this.length, this.length)));
  },
  handleComplete: function handleComplete() {
    // reset multiplier when finished
    this.o.multiplier = 1;
    this.events.onComplete.dispatch();
  },
  _updateMinMax: function _updateMinMax() {
    this.min = Math.min(this.o.from, this.o.to);
    this.max = Math.max(this.o.from, this.o.to);
    this.length = Math.abs(this.max - this.min);
    this.o.snapStep = this.length;
  }
});

BasicSwiperCore.prototype.constructor = BasicSwiperCore;

exports.default = BasicSwiperCore;