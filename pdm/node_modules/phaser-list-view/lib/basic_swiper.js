'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math_utils = require('./utils/math_utils');

var _math_utils2 = _interopRequireDefault(_math_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ptHelper = new Phaser.Point();
var defaultOptions = {
  from: 0,
  to: 200,
  direction: 'y',
  snapStep: 10,
  duration: 1, // (s) duration of the inertial scrolling simulation.
  time: {}, // contains timestamps of the most recent down, up, and move events
  swipeThreshold: 5, // (pixels) must move this many pixels for a swipe action
  swipeTimeThreshold: 250, // (ms) determines if a swipe occurred: time between last updated movement @ touchmove and time @ touchend, if smaller than this value, trigger swipe
  addListeners: true
};

// ** WORK IN PROGRESS **
//
// Similar to the Scroller class but there is no focus on a start and end of the scroll surface.
// For example with Scroller if you swiped left 3 times you would continue to go further left and
// closer to the end of the limit.
// With BasicSwiper if you swiped left 3 times, each time you receive values between -1 and 1, depending
// on the direction you swipe.
//
// TODO - consolidate BasicSwiper and Scroller. At least they could share same functions
//

var BasicSwiper = function () {
  function BasicSwiper(game, clickObject) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, BasicSwiper);

    this.game = game;
    this.clickObject = clickObject;

    this.o = this.options = Object.assign({}, defaultOptions, options);

    this._updateMinMax();

    this.addListeners();

    this.scrollObject = {};
    this.scrollObject[this.o.direction] = this.o.from;

    // set tween that will be re-used for moving scrolling sprite
    this.tweenScroll = this.game.add.tween(this.scrollObject).to({}, 0, Phaser.Easing.Quartic.Out);
    this.tweenScroll.onUpdateCallback(this.handleUpdate, this);
    this.tweenScroll.onComplete.add(this.handleComplete, this);
  }

  _createClass(BasicSwiper, [{
    key: 'addListeners',
    value: function addListeners() {
      this.events = {
        onUpdate: new Phaser.Signal(),
        onInputUp: new Phaser.Signal(),
        onInputDown: new Phaser.Signal(),
        onInputMove: new Phaser.Signal(),
        onComplete: new Phaser.Signal(),
        onSwipe: new Phaser.Signal()
      };

      this.enable();

      if (this.o.addListeners) {
        this.clickObject.inputEnabled = true;
        this.clickObject.events.onInputDown.add(this.handleDown, this);
        this.clickObject.events.onInputUp.add(this.handleUp, this);
      }
    }
  }, {
    key: 'removeListeners',
    value: function removeListeners() {
      if (this.o.addListeners) {
        this.clickObject.events.onInputDown.remove(this.handleDown, this);
        this.clickObject.events.onInputUp.remove(this.handleUp, this);
      }

      for (var property in this.events) {
        if (this.events.hasOwnProperty(property)) {
          this.events[property].removeAll();
        }
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.removeListeners();
    }
  }, {
    key: 'enable',
    value: function enable() {
      this.enabled = true;
    }
  }, {
    key: 'disable',
    value: function disable() {
      this.enabled = false;
    }
  }, {
    key: 'isTweening',
    value: function isTweening() {
      return this.tweenScroll.isRunning;
    }
  }, {
    key: 'handleDown',
    value: function handleDown(target, pointer) {
      if (!this.enabled) {
        this.clickBlocked = true;
        return;
      }
      this.clickBlocked = false;
      // console.log('handle down', pointer[this.o.direction])
      this.isDown = true;
      // console.log('input down', pointer.y)
      this.old = this.down = pointer[this.o.direction];
      this.target = 0;
      this.o.time.down = pointer.timeDown;

      if (this.o.addListeners) this.game.input.addMoveCallback(this.handleMove, this);

      //stop tween for touch-to-stop
      this.tweenScroll.stop();
      this.tweenScroll.pendingDelete = false;

      this.events.onInputDown.dispatch(target, pointer);
    }
  }, {
    key: 'handleMove',
    value: function handleMove(pointer, x, y) {
      if (!this.enabled) return;
      _ptHelper.set(x, y);
      this.diff = this.old - _ptHelper[this.o.direction];
      // console.log('diff', this.diff)
      this.target -= this.diff;

      this.old = _ptHelper[this.o.direction];

      //store timestamp for event
      this.o.time.move = this.game.time.time;

      //go ahead and move the block
      this.scrollObject[this.o.direction] = this.target;
      this.handleUpdate();

      if (this.o.emitMoving) this.events.onInputMove.dispatch(pointer, x, y);
    }
  }, {
    key: 'handleUp',
    value: function handleUp(target, pointer) {
      if (!this.enabled || this.clickBlocked) return;
      this.isDown = false;
      // console.log('end')
      if (this.o.addListeners) this.game.input.deleteMoveCallback(this.handleMove, this);

      //store timestamp for event
      this.o.time.up = pointer.timeUp;

      var o = {
        duration: this.o.duration,
        target: this.target
      };

      // *** SWIPING
      this._addSwiping(o, pointer);

      // *** SNAPPING
      this._addSnapping(o);

      this.tweenTo(o.duration, o.target);

      this.events.onInputUp.dispatch(target, pointer);
    }
  }, {
    key: '_addSwiping',
    value: function _addSwiping(o, pointer) {
      var swipeDistance = Math.abs(this.down - this.old);
      if (this.o.time.up - this.o.time.down < this.o.swipeTimeThreshold && swipeDistance > this.o.swipeThreshold) {
        var direction = pointer[this.o.direction] < this.down ? 'forward' : 'backward';

        if (direction == 'forward') {
          o.target -= this.o.snapStep / 2;
        } else {
          o.target += this.o.snapStep / 2;
        }

        this.events.onSwipe.dispatch(direction);
      }
      return o;
    }
  }, {
    key: '_addSnapping',
    value: function _addSnapping(o) {
      o.target = _math_utils2.default.nearestMultiple(o.target, this.o.snapStep);
      return o;
    }
  }, {
    key: 'tweenTo',
    value: function tweenTo(duration, target) {
      // console.log('tweenTo', duration, target)
      //stop a tween if it is currently happening
      var o = {};
      o[this.o.direction] = target;

      this.tweenScroll.onUpdateCallback(this.handleUpdate, this);
      this.tweenScroll.onComplete.add(this.handleComplete, this);

      this.tweenScroll.updateTweenData('vEnd', o, -1);
      this.tweenScroll.updateTweenData('duration', duration * 1000, -1);
      this.tweenScroll.updateTweenData('percent ', 0, -1);

      this.tweenScroll.start();
    }

    // dispatches a value between -1 and 1 depending on the direction of the swipe action.

  }, {
    key: 'handleUpdate',
    value: function handleUpdate() {
      this.events.onUpdate.dispatch(_math_utils2.default.scaleBetween(-1, 1, _math_utils2.default.percentageBetween2(this.scrollObject[this.o.direction], -this.length, this.length)));
    }
  }, {
    key: 'handleComplete',
    value: function handleComplete() {
      // reset multiplier when finished
      this.o.multiplier = 1;
      this.events.onComplete.dispatch();
    }
  }, {
    key: '_updateMinMax',
    value: function _updateMinMax() {
      this.min = Math.min(this.o.from, this.o.to);
      this.max = Math.max(this.o.from, this.o.to);
      this.length = Math.abs(this.max - this.min);
      this.o.snapStep = this.length;
    }
  }]);

  return BasicSwiper;
}();

exports.default = BasicSwiper;